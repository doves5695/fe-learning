<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<!-- <div style="width: 100px;height: 100px;background-color: red;"></div> -->
<body>
    <!-- <script src="testone.js" defer>
        // var a = 123;
        // console.log(a);
        //这样写在标签里面定义一个a,然后外面又有src是不行的打印不出来值
    </script> -->

    <!-- <script>
        // var script = document.createElement("script");
        //在这一步它已经把src引入的文件加载过来了,但是只有你把它插进body当中的时候才会运行
        // script.src = "testone.js";
        //如果直接就这么写一个函数执行,那么你打印出来的是undefined,因为现在这种方式是异步执行的,在前面那么句话请求加载testone的时候下面就已经执行完了,所以平白无故出现一个test是不好使的
        // test();
        //所以我们需要用到计时器,让这句话延迟执行,确保前面能够加载完,但是这种方法有一种不好的地方,就是如果加载的东西特别多,我们不能确保多长时间可以加载完毕
        // setTimeout(function(){
        //     test();
        // },1000);
        //就有了这种方式,onload指的是,当script标签加载完毕,才会进行的事件
        // script.onload = function () {
        //     test();
        // }
        //但是在ie中需要用到状态码,最开始的时候ie的状态码是loading,也就是加载中,它会根据script标签的加载进度来改变状态码
        // script.readyState = "loading";
        //着是ie监测状态码用的
        // script.onreadystatechange = function () {
        //     if(script.readyState == "complete" || script.readyState == "loaded") {
        //         test();
        //     } 
        // }
        //用一个函数来判断什么时候可以执行引入的js当中的代码
        // function load () {
        //     if(script.readyState) {
        //         script.onreadystatechange = function () {
        //             if(script.readyState == "complete" || script.readyState == "loaded") {
        //                 test();
        //             } 
        //             }
        //         } else {
        //             script.onload = function () {
        //                 test();
        //             }
        //         }
        //     }
        // load();
        // document.body.appendChild(script);
    </script> -->

    <!-- <script>
        //封装一个函数也就是第三种方法
        function loadScript (url,callback) {
            var script = document.createElement("script");
            if(script.readyState) {
                script.onreadystatechange = function () {
                    if(script.readyState == "complete" || script.readyState == "loaded") {
                        // callback();
                        obj["first"]();
                    }
                }
            } else {
                script.onload = function () {
                    // callback();
                    //这里也可以用对象来传
                    obj["first"]();
                }
            }
        //如果你网速太好,把script.src = url放在前面,在没运行到后面绑定事件的时候,你已经加载完了,事件无法监听到readyState的改变,因为前面已经加载完了,onload也就不会加载了也就导致没有事件触发,所以把它放后面
        script.src = url;
        document.body.append(script);
        }
        //在这个位置不能用test直接放那块,因为上面的方法是一个函数,它最开始解析的时候没有打开里面看,所以你直接放一个test进去就是未定义的,所以我们在着传一个匿名函数进去,在解析的时候不会直接打开
        // loadScript("testone.js",function() {
        //     test();
        // });
        //当时要传字符串形式
        loadScript("testone.js","first");
    </script> -->
    
    <!-- <script src="testone.js" defer>
        // window.onload = function () {
        //     //document.write具有消除文档流的功能
        //     document.write('a');
        // }
    </script> -->


    <script>
        // console.log(document.readyState);
        // //用这个事件可以查看状态改变
        // document.onreadystatechange = function () {
        //     console.log(document.readyState);
        // }
        // window.onload = function () {
        //     console.log(document.readyState);
        // }
        //DOMContentLoaded事件非常各路,只有在addEventListener中好使
        document.addEventListener('DOMContentLoaded',function () {
            console.log('a');
        },false);
    </script>
</body>
</html>