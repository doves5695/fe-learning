<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 先语法后文本,\这个东西叫做转义符号,它是不会表示出来的,转义符号可以转义自己


        // 正则表达式(RegExp)
        // 1.正则表达式的作用:匹配特殊字符或有特殊搭配原则的字符的最佳选择


        // 正则表达式有两种创建方式
        // 1.直接量   //   比较推荐
        // 2.new RegExp();




        // var reg = /a/g;
        // var str = 'aaab';
        // console.log(str.match(reg));


        // var reg = /abcd/m;
        // //在这里面我们把reg作为参数传进去,只是看着形式上一样,但是理论上,是两个不同的正则函数,如果把new操作符去掉,那么他们就指代一个了
        // var reg1 = new RegExp(reg);



        // 修饰符i   忽视大小写
        // var reg = /aaa/i;
        // var str = "AAABBBCCC";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // 修饰符g     全局的,如果加上g之后会把字符串当中所有符合规则的全拿出来
        // var reg = /a/g;
        // var str = "sdaifjijdajaodjaodaaodjaoajapfja";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // 修饰符m   执行多行匹配只有在//后面有m的时候里面加上换行符,它才会意识到这是换行了\n后面的a是新的一行
        // var reg = /a/mg;
        // var str = "abc \n  aabb";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // 表达式[abc]  查找括号里面区间内的任何字符
        // var reg = /[0-9]/g;
        // var str = "1a2b3c4d5e";
        // console.log(reg.test(str));
        // console.log(str.match(reg));

        //这个方括号[]里面写的其实是范围    例如[0-9][A-Z][a-z][A-z];
        //这样写的意思其实就是三位连着的符合该范围的字符串(一个方括号代表一位ie,里面的东西就是区间)
        // var reg = /[0-9A-z][0-9A-z][0-9A-z]/g;
        // var str = "a1bb2cc3dd4e";
        // console.log(reg.test(str));
        // console.log(str.match(reg));

        // 表达式[^abc]    查找不在方括号之间的任何字符;
        // var reg = /[^0-9]/g;
        // var str = "a1b2c3d4e5f6";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        //^这个符号就是正常的!(非符号)
        // var reg = /[^a]/g;
        // var str = "abcde";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        //|这一个竖杠表示的就是||这个或的意思
        // var reg = /(jingrui|nihao)/g;
        // var str = "jingruisaynihao";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        
        // 元字符
        // \w    用来查找单词字符     一个\w表示一个字母     它完全等于[0-9A-z_]
        // var reg = /\w\w\w/g;
        // var str = "jingrui";
        // console.log(reg.test(str));
        // console.log(str.match(reg));

        // \W      用来查找非单词字符    也就是\w没有的东西它可以有
        // var reg = /\W/g;
        // var str = "abc+a65";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \d       用来查找数字
        // var reg = /\d/g;
        // var str = "1235jingr";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \D         用来查找非数字   也就是非0-9
        // var reg = /\D/g;
        // var str = "jingrui329";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \s       用来找空白字符       根据这个可以算出来一个Tab等于4个空格
        // 一个\s等于   空格符(就是空格)   制表符(\t)  回车符(\r)  换行符(\n)  换页符(\f)   垂直换页符(\v)
        // var reg = /\s/g;
        // var str = "a  \n  b";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \S   用来查找非空白字符  
        // var reg = /\S/g;
        // var str = "123  abc";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \b    用来找单词边界
        // var reg = /\ba/g;
        // var str = "abc  adef";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // \B      用来找非单词边界
        // var reg = /\Bc/g;
        // var str = "abc  def";
        // console.log(reg.test(str));
        // console.log(str.match(reg));


        // /\t     制表符
        // var reg = /\tc/g;
        // var str = "abc\tcadad";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 

        
        // \n    换行符
        // var reg = /\n3/g;
        // var str = "12\n3"
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        // \r    回车符
        // var reg = /\r/g;
        // var str = "ab\rc"
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


         //\uxxxx     现在已经有16层编码了


         //.可以查找单个字符,除了换行和行结束符     . === [^\r\n];
        //  var reg = /./g;
        //  var str = "abc";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        // 量词
        // n+    匹配任何包含至少含有一个n的字符串   {1,无穷}
        // var reg = /\w+/g;
        // var str = "ancaaa";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        // n*   匹配任何包含0个或多个n的字符串     {0,无穷}    因为读完你想要的东西会有一个逻辑上的距离那个距离会读出来
        // var reg = /\w*/g;
        // var str = "abcd";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        // n?  匹配包含0个或一个n的字符串
        // var reg = /\w?/g;
        // var str = "abcadde";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        //贪婪原则能多就不少
        //n{X}  匹配包含X个n的序列的字符串
        // var reg = /\w{7}/g;
        // var str = "abcdefg";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        //n{x, }   匹配包含至少X个n的序列的字符串    能多就不少
        // var reg = /\w{6,}/g;
        // var str = "ajdasidhaighasidjasi";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        //n{X,Y}   匹配包含X至Y个n的序列的字符串    
        // var reg = /\w{1,5}/g;
        // var str = "abcdef";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 



        //n$       匹配任何结尾为n的字符串
        // var reg = /e$/mg;
        // var str = "abce \n ajakdje";
        // console.log(str.match(reg));
        // console.log(reg.test(str)); 


        //^n      匹配任何开头为n的字符串
        // var reg = /^a/g;
        // var str = "abce";
        // console.log(str.match(reg));
        // console.log(reg.test(str));



        //属性
        //global    判断表达式里面有没有g
        // var reg = /\w\w\w/g;
        // var str = "123456789";
        // console.log(reg.global);
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //ignoreCase   判断表达式里面有没有i大小写这个
        // var reg = /\w\w\w/ig;
        // var str = "abc123456";
        // console.log(reg.ignoreCase);
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //multiline    判断表达式里面有没有m匹配多行这个
        // var reg = /\w\w\w/m;
        // var str = "abc";
        // console.log(reg.multiline);
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //source    正则表达式的文本    不带后面的img这种
        // var reg = /\w\w\w/img;
        // var str = "abc";
        // console.log(reg.source);
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //lastIndex   找你游标的位置,跟exec配合用


        
        // 方法
        //compile    
        //test方法检验用的
        //exec    检索字符串中指定的值,返回找到的值,并确定其位置
        //它的index是告诉你它是在你游标的哪个位置上匹配的ad,当你游标滚完一遍就又回到初始位置了,如果你不加g这个全局的话,它的游标一值在0上
        // var reg = /ab/g;
        // var str = "abababab";
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(reg.lastIndex);
        // console.log(reg.exec(str));
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //()括号也叫子表达式    \1叫做匹配第一个子表达式当中的内容  \2就是第二个
        // var reg = /(a)\1/g;
        // var str = "aaaa";
        // console.log(str.match(reg));
        // console.log(reg.test(str));
        // var reg = /(a)\1(b)\2/g;
        // var str = "aabbaabb";
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //支持正则表达式的String对象的方法
        //search    索与正则表达式相匹配的值     返回匹配到的位置，如果是-1那么就是没匹配到
        //match     找到一个或多个正则表达式的匹配      在这里面如果有g的话会去掉那些累赘信息,没有的话就会和exec一样
        // var reg = /(\w)\1(\w)\2/;
        // var str = "aabb";
        // console.log(str.match(reg));


        //replace   替换与正则表达式匹配的子串     在这里面如果不结合正则表示的全局去使用的话它没有权利访问全局所以只能改变第一个,有了全局之后就能改了
        // var reg = /a/g;
        // var str = "aabb";
        // console.log(str.replace(reg,'c'));


        //spilt     把字符串分割为字符串数组      按照你的正则表达式去拆你表达式写的啥就拆成啥
        // var reg = /jingrui/g;
        // var str = "55+jingrui1595949";
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        // aabb变成bbaa
        // var str = "7788";
        // var reg = /(\w)\1(\w)\2/g;
        // console.log(str.replace(reg,'$2$2$1$1'));
        // //第一个参数是正则表达式的全局,第二个参数是第一个子表达式的内容,以此类推
        // console.log(str.replace(reg,function ($,$1,$2) {
        //     return $2+$2+$1+$1;
        // }));


        //检查一个字符串首位是否含有数字
        // var str = "123abc123";
        // var reg = /^\d|\d$/g;
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        //检查一个字符串首尾是否都含有字符串
        // var str = "123abc123";
        // var reg = /^\d[\w\W]+\d$/g;
        // console.log(str.match(reg));
        // console.log(reg.test(str));


        // 把the-first-name变成小驼峰式
        // var str = "the-first-name";
        // var reg = /-(\w)/g;
        // console.log(str.match(reg));
        // console.log(str.replace(reg,function($,$1){
        //     return $1.toUpperCase();
        // }));


        //?=n    匹配任何紧跟其后的指定字符串n的字符串     正向预查
        // var reg = /a(?=b)/g;
        // var str = "ababac";
        // console.log(str.match(reg));
        // console.log(reg.test(str));


         //?!n   匹配任何其后没有紧接指定字符串n的字符串
        // var reg = /a(?!b)/g;
        // var str = "ababaaacae";
        // console.log(str.match(reg));
        // console.log(reg.test(str));
    </script>
</body>
</html>