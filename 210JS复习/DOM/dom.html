<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<!-- <div id="jr" class="one"  style="width: 100px;height: 100px;background-color: yellow;"></div>
<div id="jj" class="two" style="width: 100px;height: 100px;background-color: red;"></div> -->
<!-- <div></div>
<div class="demo"></div>
<div></div> -->
<!-- <div>
    <span>
        <a href=""></a>
        <strong></strong>
        <p></p>
    </span>
</div> -->
<!-- <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br> -->
<!-- <div style="width: 100px;height: 100px;background-color: red;"></div> -->

<!-- <div class="wai" style="width: 300px;height: 300px;background-color: red;">
    <div class="zhong" style="width: 200px;height: 200px;background-color: yellow;">
        <div class="nei" style="width: 100px;height: 100px;background-color: green;"></div>
    </div>
</div> -->


<div style="width: 100px;height: 100px;background-color: red;"></div>
<body>
    <script>
        // DOM操作四元素包括增删改查
        // DOM也就是 Document Object Model
        // Dom定义了表示和修改html文档的所需要的方法,Dom是宿主对象,是浏览器厂商定义的方法,是用来操作html和xml功能的一类对象的集合
        // 它可以把js和html文档结合,它是用来让js处理html文档的方法集合
        // Document对象
        // 每个载入浏览器的HTML文档都会成为Document对象,Document对象可以让我们从脚本中对HTML页面中的所有元素进行访问
        // Document对象是window对象的一部分,可以通过window.document属性对其进行访问


        //document对象方法中的增删改查
        // 查
        // getELementById  它选的是你设置的元素的id的名字,可以选出来
        // var divOne = document.getElementById('jr');
        // divOne.style.width = '30px';
        // divOne.style.height = '30px';
        // divOne.style.backgroundColor = 'red';

        // getELementByTagName     用tagname来选择查看的时候记得在后面的中括号当中写上你想要查询的位数,因为通过标签选择器选择出来的是一组,是一个类数组形式,它有索引位
        // var divCol = document.getElementsByTagName('div')[0];
        // divCol.style.width = '30px';
        // divCol.style.height = '30px';
        // divCol.style.backgroundColor = 'red';

        // getELementByclassName   通过你想要查找元素的class名来查找元素,在ie8和ie8以下的ie版本中没有,可以多个class一起选择,所以还要加上索引位
        // var divOne = document.getElementsByClassName('one')[0];
        // divOne.style.width = '30px';
        // divOne.style.height = '30px';
        // divOne.style.backgroundColor = 'red';


        // querySelector     只返回匹配的第一个元素,如果没有那么返回null,相当于在括号里面写css选择器
        // var div = document.querySelector('div');
        // div.style.backgroundColor = 'blue';
        // 由例子可以看出来,第一个div最开始是黄色,我们通过querySelector方法来选择了div元素,但是只改变了第一个div元素的颜色
        // var div = document.querySelector('span');
        // console.log(div);//返回null


        // querySelectorAll   返回匹配的元素集合,如果没有匹配项,返回空的节点数组(Nodelist),返回的结果是静态的,之后改变Document结构的改变不会影响到之前的取值结果,它选取出来的是一个组
        


        // querSelector和querSelecttorAll虽然很理想但是有缺点,1.是因为在ie7和ie7以下版本不适用(但是现在基本上不用ie6,ie7了,所以影响不大)
        // 2.最致命的缺点,他们两选出来的都不是实时的
        // var divCol = document.getElementsByTagName('div');
        // var divDemo = document.getElementsByClassName('demo')[0];
        // 当用getElementsByTagName这个方法选取出来的时候是实时的,删除修改会发生变化
        // var divCol = document.querySelectorAll('div');
        // var divDemo = document.getElementsByClassName('demo')[0];
        // 用querSelector和querSelecttorAll方法来选取的时候是静态的,也就是说选出来之后再对document做一些改变并不会显示出来,就好像拍照一下,照完再去改变素材,已经拍出来的东西并不会发生改变



        // 遍历节点树
        // parentNode -> 父节点(节点的最顶层是document)
        // childNodes -> 子节点(空格注射还有回车都算是子节点,标签节点不一定是子节点)
        // firstChild -> 第一个子节点
        // lastChild  -> 最后一个子节点
        // nextSibling -> 后一个兄弟节点
        // previousSibling  -> 前一个兄弟节点
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // console.log(strong.parentNode);//span
        // console.log(div.childNodes);//Nodelist[text,span,text];
        // console.log(div.firstChild);//#text
        // console.log(div.lastChild);//#text
        // console.log(a.nextSibling);//#text
        // console.log(strong.previousSibling);//#text
        // 因为这些都是找节点,空格注释回车啥的都是节点如果写的时候不写空格回车啥的,就会出现我们属性的标签了
        // console.log(a.previousSibling);
        // console.log(div.firstChild);
        

        // 基于元素节点树的遍历(元素节点也就是我们常说的标签)
        // 除child以为ie9以下全没有
        // paremtElement -> 返回当前元素的父元素节点(IE不兼容)
        // children -> 只返回当前元素的元素子节点
        // node.childElementCount === node.children.length 当前元素节点的子元素节点个数(IE不兼容)
        // firstElementChild -> 返回的是第一个元素节点(IE不兼容)
        // lastElementChild  -> 返回的是最后一个元素节点(IE不兼容)
        // nextElementSibling / previousElementSibling  返回后一个/前一个兄弟元素节点(IE不兼容)
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // console.log(div.parentElement);//body
        // console.log(div.children);
        // console.log(div.childElementCount);//结果是当前元素节点的子元素节点个数
        // console.log(div.children.length);//它与div.childElementCount完全相等(===);
        // console.log(span.firstElementChild);//a标签
        // console.log(span.lastElementChild);//p标签
        // console.log(strong.nextElementSibling);//p标签
        // console.log(strong.previousElementSibling);//a标签


        // 节点的四大属性
        // nodeName  元素的标签名字,以大写形式表示,只读(只能读取不能赋值)
        // nodeValue   Text(文本)节点或Comment(注释)节点的文本内容,可以读写
        // nodeType  该节点的类型,只读
        // attribute   Element节点的属性集合(只有元素节点上面有)
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // console.log(div.nodeName);//DIV
        // console.log(div.firstChild.nodeType);//3


        // 节点的类型(nodetype用来获取节点的类型)
        // 元素类型 —— 1
        // 属性节点 —— 2
        // 文本节点 —— 3
        // 注释节点 —— 8
        // document —— 9
        // DocumentFragment —— 11 


        // Document 是 document的构造函数
        // Document.prototype是document的原型

        // dom当中的方法都是一级一级定义在原型链上的


        // 节点的一个方法Node.hasChildNodes();
        // 用来判断当前元素的子节点元素,文本也算哦
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // console.log(div.firstChild.hasChildNodes);


        // Dom元素的增删插替
        // 增
        // document.creatElement();   增加一个元素节点,括号里面依然是字符串
        // document.creatTextNode();  增加一个文本节点,这个文本是可以插入到页面当中去展示的
        // document.creatComment();   增加一个注释文本

        // 删
        // parent.removeChild();      这相当于一个剪切
        // child.remove();            这个删了就真没了啊,控制台当中返回的是undefined

        // 插
        // PARENTNODE.appendChild();   让父节点去调用这个方法想让谁插进去就写谁,父节点的后面插入一个节点(这类似于一个push方法,在最后面加入),假如是你选择出来的标签也可以调用这个方法
        // PARENTNDOE.insertBefore(a,b);   它叫做在b之前插入a

        // 替
        // parent.replaceChild(new,origin);   这也相当于剪切
        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // var b = document.createElement('b');//增加
        // div.appendChild(b);//插
        // div.removeChild(b);//删
        // span.insertBefore(b,strong);//在strong标签之前插入b
        // span.replaceChild(b,a);//把span当中的a标签用b标签去替换


        // innerHtml方法   可以改变html当中的内容
        // innerHtml = ???    是覆盖会把之前的html内容覆盖掉
        // 当我们用innerHTML +=  的时候可以追加文本   
        // 想要往里面加标签的时候记得用字符串形式
        // 它甚至可以拿出来body里面的东西

        // innerText(火狐不兼容) / textContent(老版本IE不好使)
        // 当使用innerText的时候会把其他标签也砍掉,使用要慎重,当你修改innerText的时候其他带文本的标签也没了
        // textContent也会改变带文本的标签

        // Element节点的一些方法
        // ele.setAttribute();
        // ele.getAttribute();
        // 这两个方法都是运用到行间,一个是设置,一个是访问,例如div.setAttribute('class','demo'); 这个方法就是在div当中设置一个行内属性叫做"class" = 'demo';
        // div.getAttribute('class');  这个就是用来把刚才添加进去的行间属性,返回出来

        // var div = document.getElementsByTagName('div')[0];
        // var span = document.getElementsByTagName('span')[0];
        // var strong = document.getElementsByTagName('strong')[0];
        // var a = document.getElementsByTagName('a')[0];
        // div.setAttribute('class','demo');
        // div.getAttribute("class");


        // Date其实是一个构造函数
        // getDate() 告诉你代码运行的时候是哪天
        // getMonth() 告诉你代码运行的时候是几月,但是它比较呆,它是从0开始算的
        // getDay()   告诉你代码运行的时候是周几
        // 1970年1月1日,是计算机的纪元年
        // getFullyear()  才是最正确的返回year的方法
        // getTime()返回自 1970 年 1 月 1 日午夜以来与指定日期的毫秒数。 

        // parse方法写字Date上面的


        // var date = new Date;
        // console.log(date.getDate());//16号
        // console.log(date.getDay());//周四
        // console.log(date.getMonth())//1月,因为是从0开始算的


        //DOM的基本操作
        // 求滚动条
        // window.pageXOffset;   //求滚动条的x轴距离
        // window.pageYOffset;   //求滚动条的Y轴距离
        // 以上两个方法IE8及其IE8以下不兼容

        // 在ie当中如何实现求滚动条(在ie中兼容性比较混乱,两种方式在一个ie版本中只能有一个好使)
        // document.body.scrollTop  /  document.documentElement.scrollTop
        // 因为兼容性比较混乱,用的时候我们用两个值相加,因为不可能存在两个同时有值
        

        // 查看视口的尺寸
        // window.innerWidth;   //宽度
        // window.innerHeight;  //高度
        // 以上两个方法IE8及其IE8以下不兼容
        // 在ie中的方法
        // document.documentElement.clientWidth
        // document.documentElement.clientHeight
        // 标准模式下任何浏览器都兼容
        // 怪异模式方法
        // document.body.clientHeight;
        // document.body.clientWidth;

        // 当我们把<!DOCTYPE html>删掉,这个浏览器就变成了混杂模式,加上这个标签就是标准模式

        // CSS1Compat    表示的是标准模式
        // BackCompat    表示的是怪异(混杂)模式


        // 查看元素的几何尺寸
        // domElement.getBoundingClientRect();
        // 兼容性很好
        // 在你document内的元素调用该方法的时候,会返回一个对象,对象当中有left,top,right,buttom等属性
        // left和top表示左上角的X和Y坐标
        // right和buttom表示右下角的X和Y的坐标
        // height和windth老版本ie并没有实现
        // 返回的结果不是实时的它是一个静态的,当你调用之后改变元素的时候,它的结果不会发生改变
        // var div = document.getElementsByTagName('div')[0];
        
        
        // div.getBoundingClientRect();//查坐标
        // div.offsetWidth;
        // div.offsetHeight;
        // 以上两个方法求的是展示区的宽高


        // 查看元素的位置
        // dom.offsetLeft   
        // dom.offsetTop
        // 他们两和position:absolute大概相同,都是去找最近的父集,如果最近的父集有定位,那么就返回该最近的父集的坐标,如果没有就相当于文档来返回坐标

        // dom.offsetParent   返回最近的有定位的父集,如果没有,返回body,body.offsetParent返回null

               
        // 让滚动条滚动
        // 这些也是在window上面
        // Scroll(),ScrollTO()   让滚动条滚动到定点值
        // ScrollBy()            让滚动条是累加滚动的 


        // 脚本化css
        // dom.style.prop
        // 可读可写的行间样式,没有兼容性问题,碰到float这种保留字属性,前面应该加css
        // 例如:float --> cssfloat
        // 符合属性必须拆除,组合单词变成小驼峰式写法
        // 例如:background-color   --> backgroundColor
        // 写入的值必须是字符串形式


        // 查询计算样式
        // window.getComputedStyle(ele,null);
        // 计算机样式只读
        // 返回的计算样式都是绝对值,没有相对单位(IE8和IE8及以下不适用)
        // 逗号后面放的是before和after,用来取伪元素的样式表

        // ele.currentStyle
        // 计算机样式只读
        // 返回计算样式的值不是经过转化的绝对值


        // window.getComputedStyle(div,null).width;

        
        // 事件
        // 事件绑定的三种方法
        // 1.最常见的方法
        // ele.onXXX = function () {}
        // 兼容性非常好,但是一个元素的同一个事件上只能绑定一个处理函数(如果你绑定了多个处理函数,那么下面的会覆盖掉上面的)
        // 2.w3c标准方法
        // ele.addEventListener(type,function(){},false); 这里面的type也是字符串类型
        // IE9以下不兼容,可以为一个事件绑定多个函数,谁先绑定就是谁
        // 3.IE独有的
        // ele.attachEvent('on' + type,function(){});
        // IE独有的,一个事件同样可以绑定多个处理此程序


        // var div = document.getElementsByTagName('div')[0];
        // div.onclick = function () {
        //     div.style.backgroundColor = 'blue';
        // }
        // div.addEventListener('click',function() {
        //     div.style.backgroundColor = 'yellow';
        // },false);
        

        // 绑定事件了如何解除
        // 1.因为最常见的方法只能绑定一个处理,所以我们可以覆盖它
        // ele.onXXX = fasle / undefined / null;
        // 2. ele.removeEventListener(type,function(){},false);
        // 如果在函数当中想要解除可以用this.removeEventListener(type,function(){},false);
        // 如果函数是匿名函数,我们可以用argument.calle方法
        // 3.ele.detachEvent('on' + type,function(){})
        // 如果绑定的是匿名函数那么基本上无法解除


        // var div = document.getElementsByTagName('div')[0];
        // // div.onclick = function () {
        // //     div.style.backgroundColor = 'yellow';
        // // }
        // // div.onclick = false;
        // div.addEventListener('click',method,false);
        // function method() {
        //     div.style.backgroundColor = 'yellow';
        // }
        // div.removeEventListener('click',method,false);


        // 事件处理模型
        // 事件冒泡
        // 结构上(非视觉上)存在嵌套关系的元素,会存在事件冒泡功能,即同一事件,自子元素冒泡向父元素(自底向上)
        // 事件捕获
        // 结构上(非视觉上)存在嵌套关系的元素,会存在事件捕获功能,即同一事件,自父元素捕获至子元素(事件源对象) (自顶向下)
        // 把addEventListener(type,fn,false)里面的false改成true就是捕获了,事件捕获只在w3c支持的里面有


       //冒泡
        // var wai = document.getElementsByTagName('div')[0];
        // var zhong = document.getElementsByTagName('div')[1];
        // var nei = document.getElementsByTagName('div')[2];
        // wai.onclick = function () {
        //     console.log('wai');
        // }
        // zhong.onclick = function () {
        //     console.log('zhong');
        // }
        // nei.onclick = function () {
        //     console.log('nei');
        // }

        //捕获    先把外面的抓住
        // var wai = document.getElementsByTagName('div')[0];
        // var zhong = document.getElementsByTagName('div')[1];
        // var nei = document.getElementsByTagName('div')[2];
        // wai.addEventListener('click',function () {
        //     console.log('wai');
        // },true);
        // zhong.addEventListener('click',function () {
        //     console.log('zhong');
        // },true);
        // nei.addEventListener('click',function () {
        //     console.log('nei');
        // },true);

        // IE没有事件捕获,触发顺序是先捕获后冒泡

        // focus,blur,change,submit,reset,select等事件不冒泡

        // 取消冒泡和阻止默认事件
        // 取消冒泡
        // w3c标准event.stopPropagation();但不支持ie9以下版本
        // IE独有,event.cancelBubble = true;


        //取消冒泡
        // var wai = document.getElementsByTagName('div')[0];
        // var zhong = document.getElementsByTagName('div')[1];
        // var nei = document.getElementsByTagName('div')[2];
        // wai.onclick = function (e) {
        //     e.stopPropagation();
        //     console.log('wai');
        // }
        // zhong.onclick = function (e) {
        //     e.stopPropagation();
        //     console.log('zhong');
        // }
        // nei.onclick = function (e) {
        //     e.stopPropagation();
        //     console.log('nei');
        // }


        // var wai = document.getElementsByTagName('div')[0];
        // var zhong = document.getElementsByTagName('div')[1];
        // var nei = document.getElementsByTagName('div')[2];
        // wai.onclick = function (e) {
        //     e.cancelBubble = true;
        //     console.log('wai');
        // }
        // zhong.onclick = function (e) {
        //     e.cancelBubble = true;
        //     console.log('zhong');
        // }
        // nei.onclick = function (e) {
        //     e.cancelBubble = true;
        //     console.log('nei');
        // }


        // 阻止默认事件
        // 默认事件--表单提交,a标签跳转,右键菜单等
        // 1.return false； 以对象属性的方式注册的事件才生效
        // 2.event.preventDefault(); w3c标注,ie9以下不兼容
        // 3.event.returnValue = false; 兼容IE
        
        // var div = document.getElementsByTagName('div')[0];
        // div.oncontextmenu = function (e) {
        //     e.returnValue = false;
        // }


        // 事件对象
        // event || window.event 用于IE
        // var event = e || window.event;
        // 事件源对象
        // event.target 火狐只有这个
        // event.srcElement  Ie只有这个
        // var target = event.target || event.srcElement

        // 事件委托机制
        // 利用事件冒泡,和事件源对象进行处理
        // 优点:
        // 1.性能 不需要循环所有的元素一个个绑定事件
        // 2.灵活 当有新的子元素时不需要重新绑定事件


        // 事件分类
        // 鼠标事件
        // click/mousedown/mousemove/mouseup/contextmenu/mouseover(mouseenter)/mouseout(mouseleave)
        // click是敲击的意思,敲击相当于按下去放上来所有一个click等于mousedown + mouseup
        // mouseenter和mouseleave相当于hover
        // 用button来区分鼠标的按键,0/1/2
        // DOM3标准规定:click事件只能监听左键,只能通过mousedown和mouseup来判断鼠标键


        // 键盘事件
        // keydown,keyup,keypress
        // keypress = keydown + keyup
        // press操作字符类按键
        // down全都可以操作 
        // keypress能够区分出所有的字符,能区分你是大写小写,keypress返回的是ASCII码
        // keydown只能对应每一个按键


        // 文本操作事件
        // input,focus,blur,change
        // onfocus  聚焦
        // blur     失去焦点
        // change   它观察的是你focus和blur的时候状态有没有什么差别,如果有差别就认为你change了就触发事件


        // window上面的load事件,与异步加载js有关联
    </script>
</body>
</html>