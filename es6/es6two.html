<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 对象的拓展
        // es6允许在对象当中只写属性名,不写属性值,这时属性值等于属性名所代表的变量
        // var name = 'jingrui';
        // var obj = { name };
        // console.log(obj);

        // function f1(x,y) {
        //     return {x,y};
        // }
        // function f2(x,y) {
        //     return { x : x, y : y};
        // }
        // console.log(f1(1,2));
        // console.log(f2(1,2));

        
        // js语音定义的属性有两种方法
        // var obj = {};
        // 方法一
        // obj.foo = 'nihao';
        // 方法二
        // obj['na' + 'me'] = "jingrui";

        // es5当中只能使用方法一定义属性
        // var obj  = {
        //     foo : true,
        //     abc : 123
        // }

        // es6允许字面量定义对象,用方法二(表达式)作为对象的属性名
        // let key = "name";
        // let obj = {
        //     [key]  : 'jingrui',
        //     ['a' + 'ge'] : 20
        // }


        // 例子:
        // var lastWord = 'last word';
        // var a = {
        //     'name' : 'jr' ,
        //     [lastWord] : 'word'
        // }
        // console.log(a['name']);
        // console.log(a[lastWord]);
        // console.log(a['last word']);


        // Object.is()
        // ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。
        // JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
        // ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
        // console.log(Object.is(+0,-0));//false
        // console.log(Object.is(NaN,NaN));//true
        // console.log(+0 === -0);true
        // console.log(NaN === NaN);false



        // 对象合并(其实是浅拷贝)
        // var obj1 = {
        //     name : 'jingrui'
        // }
        // var obj2 = {
        //     age : 20
        // }
        // obj2.sex = 'male';
        // var obj = {}
        // Object.assign(obj,obj1,obj2);
        // 对于这种嵌套的对象,一旦遇到同名属性
        // Object.assign的处理方法是替换而不是添加
        
        // const DEFAULTS = {
        //     loglevel : 0,
        //     outputFormat : 'html'
        // };
        // function processContent(options) {
        //     options = Object.assign({},DEFAULTS,options);
        //     console.log(options);
        // }


        // Object.keys
        // ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
        // var obj = {
        //     name : 'jingrui',
        //     age  : 20
        // }
        // console.log(Object.keys(obj));//['name','age'];
        // Object.values 
        // Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
        // var obj = {
        //     name : 'jingrui',
        //     age : 20
        // }
        // console.log(Object.values(obj));//['jingrui',20];
        // Object.entries
        // Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
        // var obj = {
        //     name : 'jingrui',
        //     age : 20
        // }
        // console.log(Object.entries(obj));//传出来的是一个二维数组



        // __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()

        // __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象

        // 该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。


        // var obj1 = {
        //     a : 1
        // }
        // var obj2 = {
        //     b : 2
        // } 
        // obj1.__proto__ = obj2;
        // console.log(obj1);
        // console.log(Object.setPrototypeOf(obj1,obj2));
        // console.log(Object.getPrototypeOf(obj1));
        

        // 拓展运算符
        // const [a,...b] = [1,2,3];
        // console.log(a);
        // console.log(b);
        
        // ES2017 将这个运算符引入了对象。
        // 扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
        // let z = { a: 3, b: 4 };
        // let n = { ...z };
        // let obj = {
        //     name : 'jingrui',
        //     age  : 20
        // }
        // let newobj = {...obj};




        // 函数扩展
        // rest参数,用于获取函数的多余参数,这样就不用使用arguments了
        // function a(...value) {
        //     console.log(value)
        // }
        // a(1,2,3,4,5);
        // 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。



        // 箭头函数
        // 语义化更好
        // 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分
        // 如果箭头函数的代码块部分多于一条语句，就要使用大括号讲将他们括起来，并且使用return语句返回
        // 由于大括号被解释为代码块 所以如果箭头函数直接返回一个对象的话必须加上一个括号
        
        // 练习
        // function insert(value) {
        //     return {into : function (array) {
        //         return {after:function (afterValue) {
        //             array.splice(array.indexOf(afterValue) + 1, 0,value);
        //             return array;
        //         }};
        //     }};
        // }

        // let insert = (value) => ({into : (array) => ({after : (afterValue) => {
        //     array.splice(array.indexOf(afterValue)+ 1,0,value);
        //     return array;
        // }})});

        // 箭头函数有几个使用注意点。
        // （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

        // （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

        // （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。


        // var id = 10;
        // function a() {
        //     setTimeout(()=>{
        //         console.log(this.id);
        //     },100)
        // };
        // var obj = {
        //     id : 20
        // }
        // a.call(obj); //20



        // class
        // Class 基本语法
        // JavaScript 语言的传统方法是通过构造函数，定义并生成新对象。
        // ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，
        // 作为对象的模板。通过class关键字，可以定义类。
        // 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，
        // 新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
        // class person {
        //     constructor (name,age) {
        //         this.name = name;
        //         this.age = age;
        //     }
        //     sex() {
        //         console.log('male');
        //     }
        //     hobbit() {
        //         console.log('play');
        //     }
        // }
        // var person1 = new person('jingrui',20);
        // var person2 = new person('zhangsan',25);
        // person2.sex();
        // person2.hobbit();
        // person1.__proto__.walk = function () {
        //     console.log('walk');
        // }

        // 代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。

        // 另外，方法之间不需要逗号分隔，加了会报错。
        // 代码表明，类的数据类型就是函数，类本身就指向构造函数。


        //constructor 方法 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。

        //类的内部所有定义的方法，都是不可枚举的（enumerable）。
        // for(var prop in person1) {
        //     console.log(prop);
        // }

        // 构造函数的prototype属性，在ES6的“类”上面继续存在。
        // 事实上，类的所有方法都定义在类的prototype属性上面。
        // console.log(person.prototype);


        // class的继承
        // Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。
        // 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
        // 实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。

        
        // class Father {
        //     constructor () {
        //         this.money = '500$';
        //     }
        // }
        // class Son extends Father{
        //     constructor () {
        //         super();
        //         this.name = 'jingrui';
        //     }
        // }
        // var son = new Son();



        // class 的静态方法
        // 子类调用父类的static方法只能在静态函数中调用
        // 无静态属性！！！！
        // class Father {
        //     constructor () {
        //         this.money = '500$';
        //     }
        //     static sayhello () {
        //         console.log('hello');
        //     }
        //     eat () {
        //         console.log('eat');
        //     }
        // }
        // class Son extends Father{
        //     constructor () {
        //         super();
        //         this.name = 'jingrui';
        //     }
        //     static Sonhello () {
        //         super.sayhello();
        //     }
        //     Soneat () {
        //         super.eat();
        //     }
        // }
        // // Son.sayhello();
        // var son = new Son();
        // son.eat();



        // Class的取值函数（getter）和存值函数（setter）
        
    </script>
</body>
</html>