<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <style>
        * {
            margin: 0;
            padding: 0;
        }
        div {
        width:  200px;
        height: 200px;
        border: 2px solid black;
        }
        input {
            border: 1px solid red;
            box-shadow: 0px 0px 2px #f01,0 0 2px inset;
        }
    </style> -->

    <!-- <style>
        input {
            text-align: right;
            border: 2px solid blue;
        }
    </style> -->
</head>
<body>
    <!-- <div>
        <span></span>
        <strong></strong>
    </div> -->
    <!-- <input type="text">
    <div></div> -->

    <!-- minute:<input value="0">
    second:<input value="1"> -->


    <!-- <div>
        <span></span>
        <p></p>
        <strong></strong>
    </div> -->


    <!-- <div>1</div>
    <div>3</div>
    <div>2</div>
    <div>9</div>
    <div>6</div> -->


    
    <script>
        // 封装函数,返回元素e的第n层祖先节点
        // function retParent(e,n) {
        //     while ( e && n ) {
        //         e = e.parentNode;
        //         n --;
        //     }
        //     return e;
        // }
        // var strong = document.getElementsByTagName('strong') [0];

        // 封装函数,返回元素e的第n个兄弟元素节点,n为正,返回后面的兄弟元素节点,n为负,返回前面的,n为0,返回自己
        // function retSibling (e,n) {
        //     while (e && n) {
        //         if( n > 0 ) {
        //             e = e.nextElementSibling;
        //             n -- ;
        //         } else {
        //             e = e.previousElementSibling;
        //             n ++;
        //         }
        //     }
        //     return e;
        // }
        // var span = document.getElementsByTagName('span') [0];
        // var strong = document.getElementsByTagName('strong') [0];

        // 封装函数,返回元素e的第n个兄弟元素节点,n为正,返回后面的兄弟元素节点,n为负,返回前面的,n为0,返回自己,兼容版本
        // function retSibling(e,n) {
        //     while(e && n) {
        //         if( n > 0) {
        //             if(e.nextElementSibling) {
        //                 e = e.nextElementSibling;
        //             } else {
        //                 for( e = e.nextSibling; ! e.nextSibling == 1; e = e.nextSibling) {}
        //             }
        //             n --;
        //         } else {
        //             if(e.previousElementSibling) {
        //                 e = e.previousElementSibling;
        //             } else {
        //                 for( e = e.previousSibling; !e.previousSibling ==1; e= e.previousSibling) {}
        //             }
        //             n ++;
        //         }
        //     }
        //     return e;
        // }
        // var span = document.getElementsByTagName('span') [0];
        // var strong = document.getElementsByTagName('strong') [0];

        // 编辑函数,封装myChildren功能,解决以前部分浏览器的兼容性功能
        // Node.prototype.mychildren = function () {
        //     var child = this.childNodes;
        //     var len = child.length;
        //     var obj = {
        //         length : 0,
        //         push : Array.prototype.push,
        //         splice : Array.prototype.splice
        //     }
        //     for( var i = 0 ; i < len; i++) {
        //         if(child[i].nodeType == 1) {
        //             obj.push(child[i]);
        //         }
        //     }
        //     return obj;
        // }
        // var div = document.getElementsByTagName('div') [0];

        
        
        // var div = document.createElement('div');
        // var text = document.createTextNode('abc');
        // var comment = document.createComment('this is comment');
        // div.appendChild(text);
        // div.appendChild(comment);
        // document.body.appendChild(div);

        // var div = document.createElement('div');
        // var p = document.createElement('p');
        // var text = document.createTextNode('姬成,你最帅！');
        // document.body.appendChild(div);
        // p.appendChild(text);
        // div.appendChild(p);
        // div.setAttribute('class' , 'example');
        // p.setAttribute('clase' , 'slogan');


        // var input = document.getElementsByTagName('input') [0];
        // var div = document.getElementsByTagName('div') [0];
        // input.onchange = function () {
        //     div.innerHTML += this.value
        // }


        //计时器
        // var count = 0;
        // var timer = setInterval(function () {
        //     count ++;
        //     if(count > 5) {
        //         clearInterval(timer);
        //     }
        //     console.log(count);
        // },100);


        // 写一个计时器
        // var secondDom = document.getElementsByTagName('input') [1];
        // var minuteDom = document.getElementsByTagName('input') [0];
        // var second = 0;
        // var minute = 0;
        // var timer = setInterval(function () {
        //     second ++;
        //     if(second == 60) {
        //         minute ++;
        //         second = 0;
        //     }
        //     if(minute == 5) {
        //         clearInterval(timer);
        //     }
        //     secondDom.value = second;
        //     minuteDom.value = minute;
        // },100);


        //封装一个insertafter
        //创建一个em元素
        // var em = document.createElement('em');
        //把div,p,strong三个元素拿出来
        // var div = document.getElementsByTagName('div') [0];
        // var p = document.getElementsByTagName('p') [0];
        // var strong = document.getElementsByTagName('strong') [0];
        //老样子在Element的原型上封装一个函数方法,这里的afterNode就是我们要把target放在它的后面
        // Element.prototype.insertAfter = function (target,afterNode) {
        //这里面的nextNode,代表的就是下一个元素,在这里面我们用afterNode.nextElementSibling来判断它下面是不是还有元素,如果没有那么就不会执行if,我们就会用appendchild,在最后面插入一个元素
        //     var nextNode = afterNode.nextElementSibling;
        //     if(nextNode) {
        //         this.insertBefore(target,nextNode);
        //     } else {
        //         this.appendChild(target);
        //     }
        // }


        //如何让div当中的内容按顺序排列
        //我们首先先把div的集合拿出来
        // var divCol = document.getElementsByTagName('div');
        // //然后我们利用slice方法把类数组变成数组,再用点call方法把this指向divCol
        // var arr = Array.prototype.slice.call(divCol);
        // //最后一步我们利用冒泡排序方法
        // arr.sort(function (a,b) {
        //     return parseInt(a.innerText) - parseInt(b.innerText);
        // })


        var date = new Date();
    </script>
</body>
</html>