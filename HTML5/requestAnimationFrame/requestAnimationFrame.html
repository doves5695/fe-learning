<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
    </style>
</head>
<div></div>
<body>
    <script src="worker.js"></script>
    <script>
        //让方块动   可以写动画
        // var div = document.getElementsByTagName("div")[0];
        // var pos = 0;
        // var callback;
        // function move () {
        //     pos+=10;
        //     if(pos < 1000) {
        //         div.style.left = pos + 'px';
        //         requestAnimationFrame(move);
        //     } else {
        //         div.style.left = "1000px";
        //         cancelAnimationFrame(callback);
        //     }
        // }
        // move();


        // 客户端存储问题
        // 1.storage
        // localStorage
        // localStorage.name = "jingrui";
        // var obj = {
        //     name : 'nihao',
        //     age : 20
        // }
        // localStorage.obj = JSON.stringify(obj);
        
        
        // sessionStorage
        // sessionStorage.age = 20;
        

        // localStorage和sessionStorage区别
        // 会有一个窗口的限制,localStorage设置了可以在另外一个窗口中找到它,sessionStorage不可以
        // localStorage是永久了的,就算关闭了窗口下次也可以找到,除非你手动删除它
        // sessionStorage是临时的,窗口只要关闭就没有了


        // 如何取出数据
        // localStrorage.name
        // JSON.parse(localStorage.info)



        // API
        // 1.setitem(name,val)  //设置属性值
        // console.log(localStorage.setItem("number","2020020706"));
        // 2.getitem(name)   //获得属性值
        // console.log(localStorage.getItem("number"));
        // 3.removeitem(name)   //移除属性
        // console.log(localStorage.removeItem("name"));
        // 4.clear()    //清除属性       
        // console.log(localStorage.clear());


        
        // Cookie
        //用谷歌测试的时候记得把服务器打开
        // 1.设置cookie值
        // document.cookie = "name=aimee";
        // (每次只能设置一个值,因为浏览器会认为后面的键值对是这个cookie的属性)
        // 2.获得cookie值
        // document.cookie
        // 转义方式
        // 1.encodeURIComponent()    //   转义
        // 2.decodeURIComponent()    //  通过这个方法再转回来
        // 不建议出现分号,逗号,空格等奇怪的符号

        // 1.设置cookie存储期限
        // document.cookie = "name=scott;max-age=1000";
        // 2.expires当前时间加上保存时间
        // var timestamp = (new Date()).getTime() + 10000;
        // var expires = new Date(timestamp).toGMTString();
        // document.cookie = "name=scott;expires = "+expires;
        // 一般现在都使用toUTCString


        // 删除cookie max-age=0
        // 需要带上键值对
        // document.cookie = "name=scott;max-age=0";

        
        // history
        // history.back() // 往回翻
        // history.forward()   //往前翻
        // history.go()    //翻页跳转
        // 通过修改hash和hashchange事件来实现历史记录管理
        // 1.pushState
        // history.pushState(state,title,url);   // 添加一条历史记录
        // 2.replaceStatehistory.replaceState(state,title,url);   //替换当前的历史记录


        // 参数
        // state: 一个与指定网址相关的状态对象,popstate事件触发时,该对象会传入回调函数中,如果不需要这个对象,此处可以填null
        // title: 新页面的标题,但是所有浏览器目前都忽略这个值,因此这里可以填null
        // url : 新的网址,必须与当前页面处在同一个域m浏览器的地址栏将显示这个网址


        // 1.popstate事件
        // 历史记录发生改变时触发
        // 调用history.pushState() 或者history.replaceState()不会触发popstate
        // 2.hashchange事件
        // 当页面的hash值改变的时候触发,常用于构建单页面应用




        // Worker
        // Worker相对于一个外包,如果你一个处理的程序很复习阻塞其他进程很久,worker就相对于新开一个进程
        // var worker = new Worker("worker.js");
        // worker文件必须和主文件满足同源策略


        // worker和主线程之间的通信
        // 1.postMessage方法()
        // 2.message方法



        // 主进程代码
        // var worker = new Worker("worker.js");
        // worker.onmessage = function (e) {
        //     console.log(e.data);
        // }
        // worker.postMessage(50);


        // 结束一个worker
        // close()在worker作用域中调用(worker.js)       这个相对于自己辞职,老板并不能实时的知道你干到哪块了所以不推荐
        // terminate()在worker对象上调用(主进程的worker对象上worker.terminate);                 这个是老板给你开除了,老板什么都知道比较推荐



        // worker的其他特性
        // 1.importScripts('./mat1.js','./math2.js')
        // worker只是window的子集,自能实现部分功能,不能获取到window.document,所以这里不要引jueryzepto,可以引入一些计算类的库

        // 2.作用域globalWorkerScope
        // 可以继续生成woker对象(暂时还不支持)
        // navigator
        // XMLhttpRequest
        // setTimeout/setInterval

    </script>
</body>
</html>